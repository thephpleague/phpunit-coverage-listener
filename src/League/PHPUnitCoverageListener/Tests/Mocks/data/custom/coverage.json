{"repo_token":"XKUga6etuxSWYPXJ0lAiDyHM2jbKPQAKC","source_files":[{"name":"League\/PHPUnitCoverageListener\/Collection.php","source":"<?php namespace League\\PHPUnitCoverageListener;\n\nuse \\IteratorAggregate;\nuse \\Countable;\n\n\/**\n * Collection class\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass Collection implements IteratorAggregate, Countable\n{\n    \/**\n     * Parameter storage.\n     *\n     * @var array\n     *\/\n    protected $parameters;\n\n    \/**\n     * Constructor.\n     *\n     * @param array $parameters An array of parameters\n     *\n     * @api\n     *\/\n    public function __construct(array $parameters = array())\n    {\n        $this->parameters = $parameters;\n    }\n\n    \/**\n     * Returns the parameters.\n     *\n     * @return array An array of parameters\n     *\/\n    public function all()\n    {\n        return $this->parameters;\n    }\n\n    \/**\n     * Adds parameters.\n     *\n     * @param array $parameters An array of parameters\n     *\/\n    public function add(array $parameters = array())\n    {\n        $this->parameters = array_replace($this->parameters, $parameters);\n    }\n\n    \/**\n     * Sets a parameter by name.\n     *\n     * @param string $key   The key\n     * @param mixed  $value The value\n     *\/\n    public function set($key, $value)\n    {\n        $this->parameters[$key] = $value;\n    }\n\n    \/**\n     * Returns true if the parameter is defined.\n     *\n     * @param string $key The key\n     *\n     * @return Boolean true if the parameter exists, false otherwise\n     *\/\n    public function has($key)\n    {\n        return array_key_exists($key, $this->parameters);\n    }\n\n    \/**\n     * Removes a parameter.\n     *\n     * @param string $key The key\n     *\/\n    public function remove($key)\n    {\n        unset($this->parameters[$key]);\n    }\n\n    \/**\n     * Returns an iterator for parameters.\n     *\n     * @return \\ArrayIterator An \\ArrayIterator instance\n     *\/\n    public function getIterator()\n    {\n        return new \\ArrayIterator($this->parameters);\n    }\n\n    \/**\n     * Returns the number of parameters.\n     *\n     * @return int The number of parameters\n     *\/\n    public function count()\n    {\n        return count($this->parameters);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,4,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,2,null,null,1]},{"name":"League\/PHPUnitCoverageListener\/Listener.php","source":"<?php namespace League\\PHPUnitCoverageListener;\n\nuse League\\PHPUnitCoverageListener\\ListenerInterface;\nuse League\\PHPUnitCoverageListener\\PrinterInterface;\nuse League\\PHPUnitCoverageListener\\HookInterface;\nuse League\\PHPUnitCoverageListener\\Collection;\nuse Symfony\\Component\\Yaml\\Yaml;\nuse \\SimpleXMLElement;\n\n\/**\n * Main PHPUnit listener class\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass Listener implements ListenerInterface\n{\n    \/**\n     * @var string\n     *\/\n    protected $directory;\n\n\t\/**\n\t * @var PrinterInterface\n\t *\/\n\tprotected $printer;\n\n\t\/**\n\t * @var HookInterface\n\t *\/\n\tprotected $hook;\n\n    \/**\n     * Listener constructor\n     *\n     * @param array Argument that sent from phpunit.xml\n     * @param bool Boot flag \n     *\/\n    public function __construct($args = array(), $boot = true)\n    {\n        \/\/ Get printer\n        $this->ensurePrinter($args);\n\n    \t$this->printer = $args['printer'];\n\n        \/\/ Get directory\n        $this->directory = (isset($_SERVER['PWD'])) ? realpath($_SERVER['PWD']) : getcwd();\n\n        if ($boot) {\n\t    \t$listener = $this;\n\n\t        \/\/ Register the method to collect code-coverage information\n\t        register_shutdown_function(function() use ($args, $listener) { $listener->handle($args); });\n        }\n    }\n\n    \/**\n     * Main handler\n     *\n     * @param array\n     *\/\n    public function handle($args)\n    {\n        \/\/ Starting point!\n        $this->printer->out(\"\\n\\n\".'Collecting CodeCoverage information...');\n\n        \/\/ Just collect or also send?\n        if (array_key_exists('send', $args) && $args['send'] === false) {\n            \/\/ In some point we may only want to generate the payload\n            \/\/ so if 'send' parameter exists and set to false we'll only\n            \/\/ collect and write code-coverage payload\n            $this->collectAndWriteCoverage($args);\n        } else {\n            \/\/ Default is to collect and send\n            $this->collectAndSendCoverage($args);\n        }\n\n        \/\/ Done\n        $this->printer->out('Done.');\n    }\n\n    \/**\n     * Printer getter\n     *\n     * @return PrinterInterface\n     *\/\n    public function getPrinter()\n    {\n    \treturn $this->printer;\n    }\n\n    \/**\n     * Directory getter\n     *\n     * @return Path from which the script runs\n     *\/\n    public function getDirectory()\n    {\n        return $this->directory;\n    }\n\n    \/**\n     * Main api for collecting code-coverage information and write it into json payload\n     *\n     * @param array \n     *\/\n    public function collectAndWriteCoverage($args)\n    {\n        if ($this->valid($args)) {\n            extract($args);\n\n            \/\/ Check for exist and valid hook\n            if (isset($hook) && $hook instanceof HookInterface) {\n                $this->hook = $hook;\n                unset($hook);\n            }\n\n            \/\/ Get the realpath coverage directory\n            $coverage_dir = realpath($coverage_dir);\n            $coverage_file = $coverage_dir.DIRECTORY_SEPARATOR.self::COVERAGE_FILE;\n            $coverage_output = $coverage_dir.DIRECTORY_SEPARATOR.self::COVERAGE_OUTPUT;\n\n            \/\/ Get the coverage information\n            if (is_dir($coverage_dir) && is_file($coverage_file)) {\n                \/\/ Build the coverage xml object\n                $xml = file_get_contents($coverage_file);\n                $coverage = new SimpleXMLElement($xml);\n\n                \/\/ Prepare the coveralls payload\n                $data = $this->collect($coverage, $args);\n\n                \/\/ Write the coverage output\n                $this->printer->out('Writing coverage output...');\n                file_put_contents($coverage_output, json_encode($data->all(), JSON_NUMERIC_CHECK));\n            }\n        }\n    }\n\n    \/**\n     * Main api for collecting code-coverage information\n     *\n     * @param array Contains repo secret hash, target url, coverage directory and optional Namespace\n     *\/\n    public function collectAndSendCoverage($args)\n    {\n        \/\/ Collect and write out the data\n        $this->collectAndWriteCoverage($args);\n\n        if ($this->valid($args)) {\n            extract($args);\n\n            \/\/ Get the realpath coverage directory\n            $coverage_dir = realpath($coverage_dir);\n            $coverage_output = $coverage_dir.DIRECTORY_SEPARATOR.self::COVERAGE_OUTPUT;\n\n            \/\/ Send it!\n            $this->printer->out('Sending coverage output...');\n            $payload = array('json_file'=>'@'.$coverage_output); \n            $ch = curl_init(); \n            curl_setopt($ch, CURLOPT_URL, $target_url); \n            curl_setopt($ch, CURLOPT_POST,1); \n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n\n            \/\/ Save output into output buffer\n            ob_start();\n            $result = curl_exec ($ch); \n            $curlOutput = ob_get_contents();\n            ob_end_clean();\n\n            curl_close ($ch); \n            $this->printer->printOut('cURL Output:'.$curlOutput); \n            $this->printer->printOut('cURL Result:'.$result);\n        }\n    }\n\n    \/**\n     * Argument validator\n     *\n     * @param array\n     * @return bool\n     *\/\n    protected function valid($args = array())\n    {\n         return array_key_exists('repo_token', $args) \n            && array_key_exists('target_url', $args)\n            && array_key_exists('coverage_dir', $args)\n            && array_key_exists('namespace', $args);\n    }\n\n    \/**\n     * Printer validator\n     *\n     * @param array\n     * @throws RuntimeException\n     *\/\n    protected function ensurePrinter($args)\n    {\n        if ( ! isset($args['printer'])) {\n            throw new \\RuntimeException('Printer class not found');\n        }\n\n\n        if ( ! $args['printer'] instanceof PrinterInterface) {\n            throw new \\RuntimeException('Invalid printer class');\n        }\n    }\n\n    \/**\n     * Main collector method\n     *\n     * @param SimpleXMLElement Coverage report from PHPUnit\n     * @param array\n     * @return Collection\n     *\/\n    protected function collect(SimpleXMLElement $coverage, $args = array())\n    {\n    \textract($args);\n\n    \t$data = new Collection(array(\n            'repo_token' => $repo_token,\n            'source_files' => array(),\n            'run_at' => gmdate('Y-m-d H:i:s -0000'),\n            'git' => $this->collectFromGit()->all(),\n        ));\n\n \t\t\/\/ Before collect hook\n     \tif ( ! empty($this->hook)) {\n     \t\t$data = $this->hook->beforeCollect($data);\n     \t}\n\n        \/\/ Prepare temporary source_files holder\n        $sourceArray = new Collection();\n\n        if (count($coverage->project->package) > 0) {\n            \/\/ Iterate over the package\n            foreach ($coverage->project->package as $package) {\n                \/\/ Then itterate on each package file\n                foreach ($package->file as $packageFile) {\n                    $this->printer->printOut('Checking:'.$packageFile['name']);\n\n                    $sourceArray->add(array(\n                        md5($packageFile['name']) => $this->collectFromFile($packageFile, $namespace)\n                    ));\n                }\n            }\n        }\n\n        if (count($coverage->project->file) > 0) {\n            \/\/ itterate over the files\n            foreach ($coverage->project->file as $file) {\n                $this->printer->printOut('Checking:'.$file['name']);\n\n                $sourceArray->add(array(\n                    md5($file['name']) => $this->collectFromFile($file, $namespace)\n                ));\n            }\n        }\n\n        \/\/ Last, pass the source information it it contains any information\n        if ($sourceArray->count() > 0) {\n            $data->set('source_files', array_values($sourceArray->all()));\n        }\n\n \t\t\/\/ After collect hook\n        if ( ! empty($this->hook)) {\n     \t\t$data = $this->hook->afterCollect($data);\n     \t}\n\n     \treturn $data;\n    }\n\n    \/**\n     * Collect code-coverage information from a file\n     *\n     * @param SimpleXMLElement contains coverage information\n     * @param string Optional file namespace identifier\n     * @throws RuntimeException\n     * @return array contains code-coverage data with keys as follow : name, source, coverage\n     *\/\n    protected function collectFromFile(SimpleXMLElement $file, $namespace = '')\n    {\n        \/\/ Validate\n        if ( ! is_file($file['name'])) throw new \\RuntimeException('Invalid '.self::COVERAGE_FILE.' file');\n\n        \/\/ Get current dir\n        $currentDir = $this->getDirectory();\n\n        \/\/ Initial return values\n        $name = '';\n        $source = '';\n        $coverage = array();\n\n        \/\/ #1 Get the relative file name\n        $pathComponents = explode($currentDir, $file['name']);\n        $relativeName = count($pathComponents) == 2 ? $pathComponents[1] : current($pathComponents);\n\n        if (empty($namespace)) {\n            $name = trim($relativeName, DIRECTORY_SEPARATOR);\n        } else {\n            \/\/ Replace backslash with directory separator\n            $ns = str_replace('\\\\', DIRECTORY_SEPARATOR, $namespace);\n            $nsComponents = explode($ns, $relativeName);\n            $namespacedName = count($nsComponents) == 2 ? $nsComponents[1] : current($nsComponents);\n\n            $name = count($nsComponents) == 2 ? $ns.DIRECTORY_SEPARATOR.trim($namespacedName, DIRECTORY_SEPARATOR) : $namespacedName;\n        }\n\n        \/\/ Then, we will overwrite any coverage block into it!\n        if (count($file->line) > 1) {\n            \/\/ #2 Build coverage data and the source code\n            $count = 0;\n            $handle = fopen($file['name'], \"r\");\n            while(!feof($handle)){\n                $source .= fgets($handle);\n                $count++;\n            }\n\n            fclose($handle);\n\n            \/\/ Here we build the default coverage values\n            $coverage = array_fill(0, $count, null);\n\n            foreach ($file->line as $line) {\n                $attributes = current($line->attributes());\n\n                \/\/ Only stmt would be count\n                if (isset($attributes['type']) \n                    && isset($attributes['count']) \n                    && $attributes['type'] === 'stmt') {\n\n                    \/\/ Decrease the line number by one\n                    \/\/ since key 0 (within coverage array) is actually line number 1\n                    $num = (int) $attributes['num'] - 1;\n\n                    \/\/ Ensure it match count boundaries\n                    if ($num > 0 && $num <= $count) {\n                        $coverage[$num] = (int) $attributes['count'];\n                    }\n                }\n            }\n        }\n\n        return compact('name', 'source', 'coverage');\n    }\n\n    \/**\n     * Collect git information\n     *\n     * @return Collection\n     *\/\n    public function collectFromGit()\n    {\n        \/\/ Initial git data\n        $git = new Collection();\n\n        $gitDirectory = $this->getDirectory().DIRECTORY_SEPARATOR.self::GIT_DIRECTORY;\n\n        if (is_dir($gitDirectory)) {\n            \/\/ Get refs info from HEAD\n            $branch = '';\n            $head = Yaml::parse($gitDirectory.DIRECTORY_SEPARATOR.self::GIT_HEAD);\n\n            if (is_array($head) && array_key_exists('ref', $head)) {\n                $ref = $head['ref'];\n                $branch = array_pop(explode('\/', $ref));\n            } \n\n            \/\/ Assign branch information\n            $git->set('branch', $branch);\n\n            \/\/ Get log information\n            $logRaw = self::execute('cd '.$this->getDirectory().';git log -1');\n            $idRaw = $logRaw[0];\n            $authorRaw = $logRaw[1];\n\n            \/\/ Build head information\n            list($author, $email) = explode('<', str_replace('Author:', '', $authorRaw));\n\n            $id = trim(str_replace('commit', '', $idRaw));\n            $author_name = $committer_name = trim($author);\n            $author_email = $committer_email = trim($email, '>');\n            $message = $logRaw[4].(isset($logRaw[5]) ? '...' : '');\n\n            \/\/ Assign Head information\n            $git->set('head', compact('id', 'author_name', 'author_email', \n                            'committer_name', 'committer_email', 'message'));\n\n            \/\/ Get remotes information\n            $remotes = array();\n            $configRaw = self::execute('cd '.$this->getDirectory().';git config --local -l');\n            array_walk($configRaw,function($v) use(&$remotes)\n            {\n                if (0 === strpos($v, 'remote')) {\n                    list($key, $prop) = explode('=', $v);\n                    $k = explode('.', $key);\n                    $attribute = array_pop($k);\n                    $name = array_pop($k);\n                    $remotes[$name]['name'] = $name;\n                    $remotes[$name][$attribute] = $prop;\n                }\n            });\n\n            \/\/ Assign Remotes information\n            $git->set('remotes', array_values($remotes));\n        }\n\n        return $git;\n    }\n\n    \/**\n     * Execute a command and parse the output as array\n     *\n     * @param string \n     * @return array \n     *\/\n    protected static function execute($command)\n    {\n        $res = array();\n\n        ob_start();\n        passthru($command, $success);\n        $output = ob_get_clean();\n\n        foreach ((explode(\"\\n\", $output)) as $line) $res[] = trim($line);\n\n        return array_filter($res);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,1,null,null,2,1,null,null,1,null,null,1,0,null,null,null,0,0,0,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,0,null,null,0,0,0,0,null,null,0,0,0,null,null,0,null,0,0,null,null,0,null,null,0,0,null,null,0,0,0,0,0,0,null,null,0,0,0,0,null,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,null,null,0,0,0,null,null,0,null,0,null,0,null,0,0,null,0,0,0,0,0,0,null,0,null,0,0,null,0,0,0,0,0,null,null,0,0,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,null,null,0,null,0,0,0,null,0,0,null,0,null,null,null,0,0,0,0,0,0,null,0,null,null,0,null,null,0,0,0,null,null,0,0,0,null,null,null,0,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"League\/PHPUnitCoverageListener\/Hook\/Travis.php","source":"<?php namespace League\\PHPUnitCoverageListener\\Hook;\n\nuse League\\PHPUnitCoverageListener\\HookInterface;\nuse League\\PHPUnitCoverageListener\\Collection;\n\n\/**\n * Travis Hook\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass Travis implements HookInterface\n{\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function beforeCollect(Collection $data)\n    {\n        \/\/ Check for Travis-CI environment\n        \/\/ if it appears, then assign it respectively\n        if (getenv('TRAVIS_JOB_ID') || isset($_ENV['TRAVIS_JOB_ID'])) {\n            \/\/ Remove repo token\n            $data->remove('repo_token');\n\n            \/\/ And use travis config\n            $travis_job_id = isset($_ENV['TRAVIS_JOB_ID']) ? $_ENV['TRAVIS_JOB_ID'] : getenv('TRAVIS_JOB_ID');\n            $data->set('service_name', 'travis-ci');\n            $data->set('service_job_id', $travis_job_id);\n        }\n\n        return $data;\n    }\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function afterCollect(Collection $data)\n    {\n        return $data;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"League\/PHPUnitCoverageListener\/Printer\/ArrayOut.php","source":"<?php namespace League\\PHPUnitCoverageListener\\Printer;\n\nuse League\\PHPUnitCoverageListener\\PrinterInterface;\n\n\/**\n * Array printer\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass ArrayOut implements PrinterInterface\n{\n    \/**\n     * @var array Output array\n     *\/\n    public $output = array();\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function out($output = '')\n    {\n        $this->output[] = $output.\"\\n\";\n    }\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function printOut($output = '')\n    {\n        $this->output[] = str_pad(' ', 2, '*').' '.$output;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,0,0,null]}],"run_at":"2013-07-27 19:30:55 -0000","git":{"branch":"master","head":{"id":"c674095ed65a228ea083b16855dbc10423da69a9","author_name":"toopay","author_email":"toopay@taufanaditya.com","committer_name":"toopay","committer_email":"toopay@taufanaditya.com","message":"Refactor listener and split main api into several method for flexibility"},"remotes":[{"name":"origin","url":"git@github.com:php-loep\/phpunit-coverage-listener.git","fetch":"+refs\/heads\/*:refs\/remotes\/origin\/*"}]}}